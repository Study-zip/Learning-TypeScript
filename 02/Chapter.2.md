# Chapter 2. 타입 시스템

타입은 자바스크립트에서 다루는 값의 **형태**에 대한 설명이다.
**형태란?** 값에 존재하는 속성과 메서드 그리고 내장되어 있는 **typeof** 연산자가 설명하는 것을 의미한다.

### 타입의 종류

타입스크립트의 가장 기본적인 타입은 JS의 7가지 기본 원시 타입primitive type과 동일하다.

- null
- undefined
- boolean // true 혹은 false
- string // “”, “Hi!”, “abdsgdg”, …
- number // 0, 2.1, -4, …
- bigint // 0n, 2n, -4n, …
- symbol // Symbol(), Symbol(”Hi”), …

변수의 원시 타입을 잊어버렸다면 let 변수를 입력하고 변수 이름 위에 마우스를 올리면 자동으로 알려줌.

타입스크립트는 계산된 초깃값을 갖는 변수의 타입을 유추할 수 있을 만큼 충분히 똑똑하다.

타입 시스템Type system은 프로그래밍 언어가 프로그램에서 가질 수 있는 타입을 이해하는 방법에 대한 규칙 집합이다.
타임스크립트의 타입 시스템 기본 동작

1. 코드를 읽고 존재하는 모든 타입과 값을 이해한다.
2. 각 값이 초기 선언에서 가질 수 있는 타입을 확인한다.
3. 각 값이 추후 코드에서 어떻게 사용될 수 있는지 모든 방법을 확인한다.
4. 값의 사용법이 타입과 일치하지 않으면 사용자에게 오류를 표시한다.

### 오류 종류

타입스크립트를 작성하는 동안 자주 접하는 오류 2가지

**구문 오류**
타입스크립트가 자바스크립트로 변환되는 것을 차단한 경우
구문 오류는 타입스크립트가 코드로 이해할 수 없는 잘못된 구문을 감지할 때 발생한다.
⇒ TS는 구문 오류와 상관없이 JS 코드를 출력하기 위해 최선을 다하지만, 여러분이 원하는 출력 결과가 아닐 수 있다. 따라서 출력된 JS를 실행하기 전에 구문 오류를 수정하는 것이 좋다.

**타입 오류**
타입 검사기에 따라 일치하지 않는 것이 감지된 경우
타입스크립트의 타입 검사기가 프로그램의 타입에서 오류를 감지했을 때 발생한다. 오류가 발생했다고 해서 TS 구문이 JS로 변환되는 것을 차단하진 않는다. 하지만 코드가 실행되면 무언가 충돌하거나 예기치 않게 작동할 수 있음을 나타낸다

### 할당 가능성

타입스크립트는 변수의 초깃값을 읽고 해당 변수가 허용되는 타입을 결정한다. 나중에 해당 변수에 새로운 값이 할당되면 새롭게 할당된 값의 타입이 변수의 타입과 동일한지 확인한다.
타입스크립트 변수에 동일한 타입의 다른 값이 할당될 때는 문제가 없지만, 처음 string값으로 변수를 선언한 다음 boolean 값을 넣을 수 없다.

타입스크립트에서 함수 호출이나 변수에 값을 제공할 수 있는지 여부를 확인하는 것을 **할당가능성assignability**이라고 한다.
즉, 전달된 값이 예상된 타입으로 할당 가능한지 여부를 확인합니다.

**할당 가능성 오류 이해하기**

**“Type…is assignable to type…”** 형태의 오류는 TS코드를 작성할 때 만나게 되는 가장 일반적인 오류 중 하나이다.
해당 오류 메시지에서 언급된 첫 번째 type은 코드에서 **변수에 할당하려고 시도하는 값**이다. 두 번째 type은 첫 번째 타입, 값이 할당되는 변수다.

**타입 애너테이션**

때로는 변수에 타입스크립트가 읽어야 할 **초깃값**이 없는 경우도 있다.
타입스크립트는 나중에 사용할 변수의 초기 타입을 파악하려고 시도하지 않는다.
기본적으로 변수를 **암묵적인 any타입**으로 간주한다. 즉 변수는 세상의 모든 것이 될 수 있음을 나타낸다.

초기 타입을 유추할 수 없는 변수는 **진화하는 any**라고 부른다. 특정 타입을 강제하는 대신 새로운 값이 할당될 때마다 변수 타입에 대한 이해를 발전 시킨다.

```tsx
let rocker; // 타입 : any
rocker = "Joan Jett"; // 타입 : string
rocker.toUpperCase(); // Ok
rocker = 19.58; // 타입 : number
rocker.toUpperCase();
```

일반적으로 any 타입을 사용해 any 타입으로 진화하는 것을 허용하게 되면 타입스크립트의 타입 검사 목적을 부분적으로 쓸모없게 만든다. 타입스크립트는 **값이 어떤 타입인지 알고 있을 때 가장 잘 작동한다.** any 타입을 가진 값에는 타입스크립트의 타임 검사 기능을 잘 적용할 수 없다. 검사를 위해 알려진 타입이 없기 때문.

초깃값을 할당하지 않고도 변수의 타입을 선언할 수 있는 구문인 **타입** **애너테이션 type annotation**을 제공한다. 타입 애너테이션은 변수 이름 뒤에 배치되며 콜론(:)과 타입 이름을 차례대로 기재한다.

rocker 변수가 string임을 나타낸다.

```tsx
let rocker: string;
rocker = "Joan Jett";
```

**불필요한 타입 애너테이션**

초깃값이 있는 변수에 애너테이션을 추가하면 타입스크립트는 변수에 할당된 값의 타입이 일치하는지 확인한다.
아무것도 변하지 않는 변수에는 타입 애너테이션을 추가하지 않기를 선호한다.

**타입 형태**

변수에 할당된 값이 원래 타입과 일치하는지 확인하는 것 이상을 수행한다.
타입스크립트는 객체에 어떤 멤버 속성이 존재하는지 알고 있다.
⇒ 코드에서 변수의 속성에 접근할 때 타입스크립트는 접근하려는 속성이 해당 변수의 타입에 존재하는지 확인한다. 객체의 형태에 대한 이해를 바탕으로 할당 가능성뿐만 아니라 객체 사용과 관련된 문제도 알려준다.

**모듈**

import, export

```tsx
import { value } from "./values";
export const doubled = value * 2;
```

- **모듈 :** export 또는 import가 있는 파일
- **스크립트 :** 모듈이 아닌 모든 파일

모듈 파일에 선언된 모든 것은 해당 파일에서 명시한 export 문에서 내보내지 않는 한 모듈 파일에서만 사용할 수 있다. 한 모듈에서 **다른 파일에 선언된 변수**와 **동일한 이름으로 선언된 변수**는 다른 파일의 변수를 가져오지 않는 한 이름 **충돌로 간주하지 않는다.**

파일이 스크립트면 타입스크립트는 해당 파일을 **전역 스코프 scope로 간주**하므로 **모든 스크립트가 파일의 내용에 접근**할 수 있다. 즉, 스크립트 파일에 선언된 변수는 다른 스크립트 파일에 **선언된 변수와 동일한 이름을 가질 수 없다**.

Cannot redeclare…라는 오류가 표시되면 파일에 아직 export 또는 import 문을 추가하지 않았기 때문일 수 있다. ECMA스크립트 사양에 따라 export 또는 import 문없이 파일을 모듈로 만들어야 한다면 파일의 아무 곳에나 export{};를 추가해 강제로 모듈이 되도록 만든다.

⚠️ CommonJS와 같은 이전 모듈을 사용해서 작성된 TS파일의 import, export 형태는 인식하지 못한다.
